package A5_Q1;import java.util.Iterator;import java.util.NoSuchElementException;/**   A class that implements the ADT binary tree.      @author Frank M. Carrano   @author Timothy M. Henry   @version 4.0*/public class BinaryTree<T> implements BinaryTreeInterface<T>{   protected BinaryNode<T> root;   public BinaryTree()   {      root = null;   } // end default constructor//......................................   public BinaryTree(T rootData)   {      root = new BinaryNode<>(rootData);   } // end constructor    //......................................   public BinaryTree(T rootData, BinaryTree<T> leftTree,                                  BinaryTree<T> rightTree)   {      privateSetTree(rootData, leftTree, rightTree);   } // end constructor //......................................   public void setTree(T rootData)   {      root = new BinaryNode<>(rootData);   } // end setTree    //......................................   public void setTree(T rootData, BinaryTreeInterface<T> leftTree,                                   BinaryTreeInterface<T> rightTree)   {      privateSetTree(rootData, (BinaryTree<T>)leftTree,                                (BinaryTree<T>)rightTree);   } // end setTree //......................................  	private void privateSetTree(T rootData, BinaryTree<T> leftTree, 	                                        BinaryTree<T> rightTree)	{      root = new BinaryNode<>(rootData);      if ((leftTree != null) && !leftTree.isEmpty())         root.setLeftChild(leftTree.root);             if ((rightTree != null) && !rightTree.isEmpty())      {         if (rightTree != leftTree)            root.setRightChild(rightTree.root);         else            root.setRightChild(rightTree.root.copy());      } // end if      if ((leftTree != null) && (leftTree != this))         leftTree.clear();              if ((rightTree != null) && (rightTree != this))         rightTree.clear();	} // end privateSetTree//......................................	public T getRootData()	{//		if (isEmpty())//			System.out.println("Tree is empty"); //throw new EmptyTreeException();//		else         return root.getData();	} // end getRootData	//......................................	public boolean isEmpty()	{      return root == null;	} // end isEmpty	//......................................	public void clear()	{      root = null;	} // end clear	//......................................	protected void setRootData(T rootData)	{      root.setData(rootData);	} // end setRootData	//......................................	protected void setRootNode(BinaryNode<T> rootNode)	{      root = rootNode;	} // end setRootNode	//......................................	protected BinaryNode<T> getRootNode()	{      return root;	} // end getRootNode	//......................................	public int getHeight()	{      return root.getHeight();	} // end getHeight	//......................................	public int getNumberOfNodes()	{      return root.getNumberOfNodes();	} // end getNumberOfNodes	//......................................	public Iterator<T> getPreorderIterator()	{		return new PreorderIterator();		} // end getPreorderIterator	//......................................	public Iterator<T> getInorderIterator()	{		return new InorderIterator();		} // end getInorderIterator	//......................................	public Iterator<T> getPostorderIterator()	{		return new PostorderIterator();		} // end getPostorderIterator	//......................................	//......................................	private class PreorderIterator implements Iterator<T>	{		private StackInterface<BinaryNode<T>> nodeStack;				public PreorderIterator()		{			nodeStack = new LinkedStack<>();			if (root != null)				nodeStack.push(root);		} // end default constructor				public boolean hasNext() 		{			return !nodeStack.isEmpty();		} // end hasNext				public T next()		{			BinaryNode<T> nextNode;						if (hasNext())			{				nextNode = nodeStack.pop();				BinaryNode<T> leftChild = nextNode.getLeftChild();				BinaryNode<T> rightChild = nextNode.getRightChild();								// Push into stack in reverse order of recursive calls				if (rightChild != null)					nodeStack.push(rightChild);									if (leftChild != null)					nodeStack.push(leftChild);			}			else			{				throw new NoSuchElementException();			}					return nextNode.getData();		} // end next			public void remove()		{			throw new UnsupportedOperationException();		} // end remove	} // end PreorderIterator	//......................................	public void iterativePreorderTraverse()   {      StackInterface<BinaryNode<T>> nodeStack = new LinkedStack<>();      if (root != null)         nodeStack.push(root);      BinaryNode<T> nextNode;      while (!nodeStack.isEmpty())      {			nextNode = nodeStack.pop();			BinaryNode<T> leftChild = nextNode.getLeftChild();			BinaryNode<T> rightChild = nextNode.getRightChild();						// Push into stack in reverse order of recursive calls			if (rightChild != null)				nodeStack.push(rightChild);         			if (leftChild != null)				nodeStack.push(leftChild);                  System.out.print(nextNode.getData() + " ");      } // end while   } // end iterativePreorderTraverse		//......................................	private class InorderIterator implements Iterator<T>	{      private StackInterface<BinaryNode<T>> nodeStack;      private BinaryNode<T> currentNode;      public InorderIterator()      {         nodeStack = new LinkedStack<>();         currentNode = root;      } // end default constructor      public boolean hasNext()       {         return !nodeStack.isEmpty() || (currentNode != null);      } // end hasNext      public T next()      {         BinaryNode<T> nextNode = null;         // Find leftmost node with no left child         while (currentNode != null)         {            nodeStack.push(currentNode);            currentNode = currentNode.getLeftChild();         } // end while         // Get leftmost node, then move to its right subtree         if (!nodeStack.isEmpty())         {            nextNode = nodeStack.pop();            assert nextNode != null; // Since nodeStack was not empty                                     // before the pop            currentNode = nextNode.getRightChild();         }         else            throw new NoSuchElementException();         return nextNode.getData();       } // end next    //......................................      public void remove()      {         throw new UnsupportedOperationException();      } // end remove	} // end InorderIterator	//......................................	public void iterativeInorderTraverse()   {      StackInterface<BinaryNode<T>> nodeStack = new LinkedStack<>();      BinaryNode<T> currentNode = root;            while (!nodeStack.isEmpty() || (currentNode != null))      {         // Find leftmost node with no left child         while (currentNode != null)         {            nodeStack.push(currentNode);            currentNode = currentNode.getLeftChild();         } // end while                  // Visit leftmost node, then traverse its right subtree         if (!nodeStack.isEmpty())         {            BinaryNode<T> nextNode = nodeStack.pop();            assert nextNode != null; // Since nodeStack was not empty                                     // before the pop            System.out.print(nextNode.getData() + " ");            currentNode = nextNode.getRightChild();         } // end if      } // end while   } // end iterativeInorderTraverse	//......................................	private class PostorderIterator implements Iterator<T>	{		private StackInterface<BinaryNode<T>> nodeStack;		private BinaryNode<T> currentNode;				public PostorderIterator()		{			nodeStack = new LinkedStack<>();			currentNode = root;		} // end default constructor				public boolean hasNext()		{			return !nodeStack.isEmpty() || (currentNode != null);		} // end hasNext      public T next()      {         boolean foundNext = false;         BinaryNode<T> leftChild, rightChild, nextNode = null;                  // Find leftmost leaf         while (currentNode != null)         {            nodeStack.push(currentNode);            leftChild = currentNode.getLeftChild();            if (leftChild == null)               currentNode = currentNode.getRightChild();            else               currentNode = leftChild;         } // end while                  // Stack is not empty either because we just pushed a node, or         // it wasn't empty to begin with since hasNext() is true.         // But Iterator specifies an exception for next() in case         // hasNext() is false.                  if (!nodeStack.isEmpty())         {            nextNode = nodeStack.pop();            // nextNode != null since stack was not empty before pop                        BinaryNode<T> parent = null;            if (!nodeStack.isEmpty())            {               parent = nodeStack.peek();               if (nextNode == parent.getLeftChild())                  currentNode = parent.getRightChild();               else                  currentNode = null;            }            else               currentNode = null;         }         else         {            throw new NoSuchElementException();         } // end if                  return nextNode.getData();      } // end next/*		public T next()		{			boolean foundNext = false;			BinaryNode<T> leftChild, rightChild, nextNode = null;						// Find leftmost leaf			while (currentNode != null)			{				nodeStack.push(currentNode);				leftChild = currentNode.getLeftChild();				if (leftChild == null)					currentNode = currentNode.getRightChild();				else					currentNode = leftChild;			} // end while						// Stack is not empty either because we just pushed a node, or			// it wasn't empty to begin with since hasNext() is true.			// But Iterator specifies an exception for next() in case			// hasNext() is false.						if (!nodeStack.isEmpty())			{				nextNode = nodeStack.pop();				// nextNode != null since stack was not empty before pop                        BinaryNode<T> parent = null;            try            {               parent = nodeStack.peek();               if (nextNode == parent.getLeftChild())                  currentNode = parent.getRightChild();               else                  currentNode = null;            }				catch(EmptyStackException e)            {               currentNode = null;            }			}			else			{				throw new NoSuchElementException();			} // end if			         return nextNode.getData();		} // end next*/    //......................................      public void remove()		{			throw new UnsupportedOperationException();		} // end remove	} // end PostorderIterator		//......................................										// -------------------------------------------------------------------------------------------------------Added by Yassine		private StringBuilder sb = new StringBuilder();    /**     * PreOrderTraverse method to call      * recursive Pre Order Traverse method.     * prints out the result of the PreOrder Traverse     */    public void preOrderTraverse() {    	sb.setLength(0);        preOrderTraverse(root, 1, sb);        System.out.println("result of PreOrderTraverse Recursive Method : " + sb);    }    /**     * Recursive Method to traverse the Tree, starting from node given by user.     * @param node root Node to start PreOrder Traverse     * @param depth: level of preOrder we want     * @param sb to build the return result string     */    private void preOrderTraverse(BinaryNode<T> node, int depth, StringBuilder sb) {//    	  for (int i = 1; i < depth; i++) {//    	    sb.append(","); // indentation//    	  }    	  if (node == null) {    	    return;    	  } else {    	    sb.append(node.getData());    	    sb.append(" ");    	    preOrderTraverse(node.getLeftChild(), depth + 1, sb);    	    preOrderTraverse(node.getRightChild(), depth + 1, sb);    	  }    	}        /**     * InOrderTraverse method to call     * recursive In Order Traverse method     * prints out the result of the InOrder Traverse     */    public void inOrderTraverse() {    	sb.setLength(0);    	inOrderTraverse(root, sb);    	System.out.println("result of InOrderTraverse Recursive Method: " + sb);    	    }        /**     * Recursive Method to traverse the Tree with root specified by user     * @param node root Node of the Tree     * @param sb to build the return result string     */    public void inOrderTraverse(BinaryNode<T> node, StringBuilder sb) {    	if (node == null) {    	    return;    	} else {    		inOrderTraverse(node.getLeftChild(), sb);    		sb.append(node.getData());    		sb.append(" ");    		inOrderTraverse(node.getRightChild(), sb);    		    	}    }        /**     * postOrderTraverse method to call     * recursive postOrder Traverse method     * prints out the result of the postOrder Traverse     */    public void postOrderTraverse() {    	sb.setLength(0);    	postOrderTraverse(root, sb);    	System.out.println("result of postOrderTraverse Recursive Method: " + sb);    	    }        /**     * Recursive Method to traverse the Tree with root specified by user     * @param node root Node of the Tree     * @param sb to build the return result string     */    public void postOrderTraverse(BinaryNode<T> node, StringBuilder sb) {    	if (node == null) {    	    return;    	} else {    		postOrderTraverse(node.getLeftChild(), sb);    		postOrderTraverse(node.getRightChild(), sb);    		sb.append(node.getData());    		sb.append(" ");    	}    }// -------------------------------------------------------------------------------------------------------Added by Yassine END                                                                        } // end BinaryTree